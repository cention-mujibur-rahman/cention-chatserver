uses 'chatqueue/chatqueue';
uses 'asyncJsonRPC';

global {
	object currentUser;
}

namespace ChatMCAM {
	array lastSent;

	function _getAreaAgents( number area_id ) {
		return Array.append( [ [ 'id' => 0, 'value' => I('Forward To Agent') ] ], (closure {
			array list = [];
			Workflow.User.listFromCache(area_id).each() using ( item ) {
				if( item['id'] != currentUser.id ) {
					object user = Workflow.User.load(item['id']);
					if( user and user.acceptChat ) {
						list[] = item;
					}
				}
			};
			return list;
		}).invoke());
	}
	function _getAlternativeAnswers( number area_id ) {
			array list = [];
			array results = [];
			
			string sqlQuery = "SELECT workflow_errand_id AS id, sa.subject AS subject, sa.body AS body, sa.htmlBody AS html_body 
					   FROM workflow_errands AS e LEFT JOIN workflow_simplemessages AS se ON e.message_fkey=se.workflow_simplemessage_id 
					   LEFT JOIN workflow_answers AS a ON e.answer_fkey=a.workflow_answer_id 
					   LEFT JOIN workflow_simplemessages AS sa ON a.message_fkey=sa.workflow_simplemessage_id WHERE e._deleted=false AND workflow_errand_id 
					   IN (SELECT parent_workflow_errand_id FROM workflow_errand_tags_links 
					   WHERE child_workflow_tag_id=7) AND targetarea_fkey = ${area_id} ORDER BY subject DESC";
			
			results = ObjRunObject.rawQuery(sqlQuery);
			
			if( results ){
				list [] = [ 'id' => 0, 'value' => I('Choose Alternative answer') ];
			} else {
				
				list [] = [ 'id' => 0, 'value' => I('No Alternative Answers') ];
			}
			
			results.each() using ( row ) {
				list [] = [
					'id' => row['id'],
					'value' => row['subject']
				];
			};
			
			return list;
	}
	function _messageToArray( object message ) {
		return [
			'id' => message.id,
			'sender' => (message.user
				? (message.user.chatName
					? message.user.chatName
					: message.user.username
					)
				: (message.client
					? message.client.name
					: I('System')
					)
				),
			'body' => ._formatBody(message.message),
			'sent' => message.timestampSent,
			'sentHuman' => formatTime(message.timestampSent),
			'colour' => (message.user ? '#0000FF' : '#FF0000')
		];
	}
	
	function _formatBody( string body ) {
		object r = new Regexp('(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])', 'i');
		return r.replaceAll(body, '<a style="color:#333399;" target="_blank" href="\1">\1</a>');
	}
	
	function _getList( array area_ids, array user_ids) {
		array list = [];
		array order = [];
		array sessions = [];
		array activeList = Workflow.ChatSession.activeList(Workflow.SystemGroup.current(), area_ids, user_ids);
		array chats = [];
		string sqlQuery = "select a.session,message,clientsentlast from (
				select distinct on (session) session, client_fkey != 0 as clientsentlast
					from workflow_chatmessages
						where session in (%SESSIONS%)
						order by session,timestampsent desc
			) as a join (
				select distinct on (session) session, message
					from workflow_chatmessages
						where session in (%SESSIONS%)
						and client_fkey != 0
						order by session,timestampsent desc
			) as b on a.session = b.session;";
		
		if (activeList.size() > 0) {
			activeList.each() using ( session ) {
				sessions.push(session.id);
			};
			
			ObjRunObject.rawQuery(sqlQuery.replace('%SESSIONS%',sessions.join(','))).each() using ( chat ) {
				chats["${chat.session}"] = [
					'session' => chat.session,
					'message' => chat.message,
					'clientSentLast' => chat.clientsentlast
				];
			};
			
			activeList.each() using ( session ) {
				array chat = chats["${session.id}"];
				
				order[] = session.id;
				list["${session.id}"] = [
					'id' => session.id,
					'data' => [
						'id' => session.id,
						'areaID' => session.area.id,
						'area' => session.area.name,
						'message' => (chat and chat.message
							? (chat.message.utf8Length() > 125 ? chat.message.utf8Slice(125) + '...' : chat.message)
							: I('No Message')),
						'client' => (session.client and session.client.name ? session.client.name : I('No Name')),
						'email' => (session.client and session.client.email ? session.client.email.emailAddress : I('No Sender')),
						'assigned' => (session.user ? 1 : 0),
						'owner' => (session.user ? session.user.username : I('Unassigned')),
						'startedHuman' => formatDateTime(session.timestampStarted),
						'started' => session.timestampStarted
					],
					'style' => [
						'bg' => (session.user and session.user.id == currentUser.id ? '#CFC' : '#FFF'),
						'bold' => (session.user and session.user.id == currentUser.id and chat.clientSentLast ? true : false)
					]
				];
			};
		}
		
		return [
			'list' => list,
			'order' => order
		];
	}

	function _getAllMessages( object session ) {
		array list = [];
		Workflow.ChatMessage.listBySession(session.id).each() using ( message ) {
			list[] = ._messageToArray(message);
		};
		if( session.clientReportedAsInactive ) {
			string clientName = (session.client ? session.client.name : I('No Name'));
			list[] = [
				'id' => 0,
				'sender' => I('System'),
				'body' => I('{0} has become inactive and most likely closed the chat window.').expand(clientName),
				'sent' => session.timestampClientReportedAsInactive,
				'sentHuman' => formatTime(session.timestampClientReportedAsInactive),
				'colour' => '#000000'
			];
			list = list.sort() using ( a, b ) {
				if( a['sent'] < b['sent'] ) return -1;
				if( a['sent'] == b['sent'] ) return 0;
				if( a['sent'] > b['sent'] ) return 1;
			};
		}
		return list;
	}
	
	function _getMessages( number sessionID, number timestampLastMessage ) {
		array list = [];
		Workflow.ChatMessage.listBySessionAfterTimestampOnlyFromClient(sessionID, timestampLastMessage).each() using ( message ) {
			list[] = ._messageToArray(message);
		};
		if( not list ) {
			object session = Workflow.ChatSession.load(sessionID);
			if( not session.active ) {
				if( not session.clientReportedAsOffline ) {
					string clientName = (session.client ? session.client.name : I('No Name'));
					list[] = [
						'id' => 0,
						'sender' => I('System'),
						'body' => I('{0} has closed the chat window.').expand(clientName),
						'sent' => session.timestampEnded,
						'sentHuman' => formatTime(session.timestampEnded),
						'colour' => '#000000'
					];
					session.setValue('clientReportedAsOffline', true);
					session.save();
				}
			} else {
				// If we have not received any new messages from the client
				// we check if the client has become inactive.
				
				if( not session.clientReportedAsInactive ) {
					number now = Date.GMTnow();
					number timeout = (F('chat.inactive-timeout') ? F('chat.inactive-timeout') : 1);
					number timeoutSeconds = timeout * 60;
					number watermark = now - timeoutSeconds;
					
					if( session.timestampLastClientUpdate <= watermark ) {
						// If we get here we consider the client to have become inactive.
						// It is time to display a message.
						string clientName = (session.client ? session.client.name : 'No Name');
						list[] = [
							'id' => 0,
							'sender' => I('System'),
							'body' => I('{0} has become inactive and most likely closed the chat window.').expand(clientName),
							'sent' => now,
							'sentHuman' => formatTime(now),
							'colour' => '#000000'
						];
						session.setValue('clientReportedAsInactive', true);
						session.setValue('timestampClientReportedAsInactive', now);
						session.save();
					}
				}
			}
		}
		return list;
	}
	
	boolean _attemptedActiveSessionsCache = false;
	array _activeSessionsCache;
	function _getActiveSessionsForCurrentUser() {
		if( not ._attemptedActiveSessionsCache ) {
			._activeSessionsCache = [];
			Workflow.ChatSession.activeList(Workflow.SystemGroup.current(), Workflow.Area.idListForUserFromCache(),
				[ currentUser.id ]).each() using ( session )
			{
				._activeSessionsCache[] = session.id;
			};
		}
		return ._activeSessionsCache;
	}
	
	function _getUnseenSessions() {
		array sessionsWithUnseenMessages;
		object sessionToShow;
		sessionsWithUnseenMessages = Workflow.ChatSession.haveUnseenMessagesList(Workflow.SystemGroup.current(), currentUser.id);
		if( sessionsWithUnseenMessages ) {
			sessionToShow = sessionsWithUnseenMessages[0];
			Logger.info(Logger.APPLICATION_CHAT,
				"Sending unseen sessions [" + sessionsWithUnseenMessages.join(', ') using( session ) { return session.id; } +
				"] to ${currentUser.username} [${currentUser.id}]");
		}
		if( sessionToShow ) {
			return [
				'list' => sessionsWithUnseenMessages.process() using( session ) { return session.id; },
				'session' => [
					'id' => sessionToShow.id,
					'client' => (sessionToShow.client and sessionToShow.client.name ? sessionToShow.client.name : I('No Name')),
					'messages' => ._getAllMessages(sessionToShow),
					'externalData' => sessionToShow.externalData,
					'area' => [
						'id' => (sessionToShow.area ? sessionToShow.area.id : 0),
						'agents' => (sessionToShow.area ? ._getAreaAgents(sessionToShow.area.id) : [])
					]
				]
			];
		}
		return null;
	}

	function getUpdate( array parameters ) {
		number session_id = 0;
		array area_ids = [];
		array user_ids = [];
		
		if( currentUser.acceptChat ) {
			Logger.info(Logger.APPLICATION_CHAT, "Update -> ${currentUser.username} [${currentUser.id}] - time since last update: " + (closure {
				return Date.GMTnow() - currentUser.timestampLastChatUpdate;
			}).invoke() + " (${Date.GMTnow()})");
		}
		currentUser.setValue('timestampLastChatUpdate', Date.GMTnow());
		// currentUser.save();
		{
			object jsonRPC = new AsyncJsonRPC('localhost',8080,'/objsrv');
			jsonRPC.invoke( 'Workflow.User.save' , [ 'target' => currentUser ]) using (res) {/* do nothing */};
		}
		
		if( parameters.keyExists('areas') ) {
			parameters['areas'].toArray(',').each() using ( id ) {
				area_ids[] = id.toNumber();
			};
		}
		if( parameters.keyExists('users') ) {
			parameters['users'].toArray(',').each() using ( id ) {
				user_ids[] = id.toNumber();
			};
		}
		if( parameters.keyExists('session') ) {
			session_id = parameters['session'].toNumber();
		}
		
		return JSON.valueToJSON([
			'list' => ._getList(area_ids, user_ids),
			'current' => (closure {
				object session = Workflow.ChatSession.load(session_id);
				if( session ) {
					return [
						'client' => (session.client and session.client.name ? session.client.name : I('No Name')),
						'preview' => session.nextClientMessagePreview,
						'messages' => ._getMessages(session.id, (parameters.keyExists('timestampLastMessage')
							? parameters['timestampLastMessage'].toNumber()
							: 0))
					];
				}
				return null;
			}).invoke(),
			'unseen' => ._getUnseenSessions(),
			'count' => ._getActiveSessionsForCurrentUser().size()
		]);
	}
	
	function sendMessage( array parameters ) {
		object session = Workflow.ChatSession.load(parameters['session'].toNumber());
		if( session ) {
			number now = Date.GMTnow();
			object message = new Workflow.ChatMessage();
			message.setValue('session', session.id);
			message.setValue('timestampSent', now);
			message.setValue('message', parameters['text']);
			message.setValue('user', currentUser);
			// .lastSent[''+session.id] = message;
			message.save();
			if( now > session.timestampLastAgentMessageSent ) {
				session.setValue('timestampLastAgentMessageSent', now);
				session.save();
			}
			return JSON.valueToJSON(true);
		}
		return JSON.valueToJSON(false);			
	}
	
	function getAgents( array parameters ) {
		object session = Workflow.ChatSession.load((parameters.keyExists('session')
			? parameters['session'].toNumber()
			: 0));
		if( session ) {
			object area = Workflow.Area.load(session.area.id); // Tiny to full
			if( ExternalQueueInterface.enabled() and (area.externalID or area.solidusServiceGroupID) ) {
				array list = ExternalQueueInterface.getChatAgents(area);
				list.unshift([ 'id' => 0, 'value' => I('Forward to Agent') ]);
				return JSON.valueToJSON(list);
			} else {
				return JSON.valueToJSON(._getAreaAgents(area.id));
			}
		} else {
			return JSON.valueToJSON([]);
		}
	}

	function forwardToAgent( array parameters ) {
		number now = Date.GMTnow();
		object session = Workflow.ChatSession.load((parameters.keyExists('session')
			? parameters['session'].toNumber()
			: 0));
		object user = Workflow.User.load((parameters.keyExists('forward')
			? parameters['forward'].toNumber()
			: 0));
		object fromUser = Workflow.User.load( (session.user.id ? session.user.id : 0));
		
		if( session and user ) {
			object area = session.area;
			if( ExternalQueueInterface.enabled() and (area.externalID or area.solidusServiceGroupID) ) {
				if( ExternalQueueInterface.forwardChatToAgent(session, user) ) {
					// The chat is set to have unseen messages so that it is automatically
					// shown to the agent it is forwarded to.
					session.setValue('hasUnseenMessages', true);
					session.setValue('user', null);
					session.setValue('fromAgent', null);
					session.setValue('status', Workflow.ChatSession.STATUS_WAITING_ON_AGENT);
					session.save();
					return JSON.valueToJSON(true);
				}
			} else {
				// The chat is set to have unseen messages so that it is automatically
				// shown to the agent it is forwarded to.
				session.setValue('hasUnseenMessages', true);
				session.setValue('user', user);
				session.setValue('fromAgent', fromUser);
				session.setValue('timestampForward', now);
				session.save();
				return JSON.valueToJSON(true);
			}
		}
		return JSON.valueToJSON(false);
	}
	
	function forwardToArea( array parameters ) {
		object session;
		number now = Date.GMTnow();
		object owner = null;
		number agentsAvailable;
		array list;
		boolean create = false;
		object fromUser;
		object fromArea;
		if( parameters.keyExists('forward_area_id') or parameters.forward_area_id != 0 ) {		    
		    Logger.info(Logger.APPLICATION_CHAT, "Forwarding session [${parameters.session}] to available agents in area [${parameters.forward_area_id}]");
		    SOAP.RPC.setDefaults('http://' + request.hostname() + uriForApplicationAction('chat/interface/-/RPC'));
		    agentsAvailable = SOAP.RPC.invoke('agentsAvailable', ['area_id' => parameters.forward_area_id], 'number');
		    if( agentsAvailable ) {
			Logger.info(Logger.APPLICATION_CHAT, "Agents available in area [${parameters.forward_area_id}] and total agents are [${agentsAvailable}]");
			list = Workflow.User.availableForChatList( [ parameters.forward_area_id ] );	
			if( list ) {
			    array possibleOwners = [];
			    number lowestAmountOfAssignedChats = list[0]['count'];
			    list.each() using ( row ) {			    
				if( row['count'] < lowestAmountOfAssignedChats ) {
					lowestAmountOfAssignedChats = row['count'];
				}
			    };
			    list.each() using ( row ) {
				if( row['count'] == lowestAmountOfAssignedChats ) {
					possibleOwners[] = row['workflow_user_id'];
				}
			    };			
			    if( possibleOwners ) {
				    owner = Workflow.User.load(possibleOwners[Math.randomNumber(0, possibleOwners.size() - 1)]);
				    Logger.info(Logger.APPLICATION_CHAT, "Found possible agent [${owner.id}] under area [${parameters.forward_area_id}]");
			    }
			    create = true;
			}
			if(create){
			    session = Workflow.ChatSession.load((parameters.keyExists('session')
			    ? parameters['session'].toNumber()
			    : 0));
			    fromUser = Workflow.User.load( (session.user.id ? session.user.id : 0) );
			    fromArea = Workflow.Area.load( (session.area.id ? session.area.id : 0) );
			    if( session and owner ) {
				object area = Workflow.Area.tiny( parameters.forward_area_id.toNumber() );
				session.setValue('user', owner);
				session.setValue('area', area);
				session.setValue('fromAgent', fromUser);
				session.setValue('timestampForward', now);
				session.setValue('fromArea', fromArea);
				session.save();
				Logger.info(Logger.APPLICATION_CHAT, "Chat Session [${session.id}] successfully forwarded to User [${owner.id}] in Area [${parameters.forward_area_id}]");
				return JSON.valueToJSON(true);
			    }
			}		   
		    }else{
			Logger.info( Logger.APPLICATION_CHAT, "Trying to send chat session [${parameters.session}], forwared to area [${parameters.forward_area_id}], but no agents are available.!!" );
			return JSON.valueToJSON(false);
		    }
		}
		return JSON.valueToJSON(false);
	}
	
	function getAlternativeAnswers( array parameters ) {
		array results;
		string body;
		number errandId = ( parameters.keyExists('errandId')
			? parameters['errandId'].toNumber()
			: 0);
	        string sqlQuery = "SELECT workflow_errand_id AS id, sa.subject AS subject, sa.body AS body, sa.htmlBody AS html_body 
				  FROM workflow_errands AS e LEFT JOIN workflow_simplemessages AS se ON e.message_fkey=se.workflow_simplemessage_id 
				  LEFT JOIN workflow_answers AS a ON e.answer_fkey=a.workflow_answer_id 
				  LEFT JOIN workflow_simplemessages AS sa ON a.message_fkey=sa.workflow_simplemessage_id WHERE e._deleted=false AND workflow_errand_id = ${errandId} limit 1";
		
		results = ObjRunObject.rawQuery(sqlQuery);
		if( results ) {
			body = (results[0]['body'] ? results[0]['body'] : ( results[0]['html_body'] ? results[0]['html_body'] : I('No Answer Found')));	
		}
		return JSON.valueToJSON([ body ]);
	}
	
	function finishSession( array parameters ) {
		object session = Workflow.ChatSession.load((parameters.keyExists('session')
			? parameters['session'].toNumber()
			: 0));
		if( session ) {
			session.close(false, null);
			ChatQueueInterface.endChat(session);
			return JSON.valueToJSON(true);
		}
		return JSON.valueToJSON(false);
	}
	
	function acquireSession( array parameters ) {
		array openExternalSystem;
		object session = Workflow.ChatSession.load((parameters.keyExists('session')
			? parameters['session'].toNumber()
			: 0));
		boolean acquired = false;
		if( session and session.user and session.user.id == currentUser.id ) {
			acquired = true;
		} else if( session and session.user == null ) {
			session.setValue('user', currentUser);
			session.setValue('timestampAssigned', Date.GMTnow());
			session.save();
			acquired = true;
		}

		if( F('open-external-system') and session ){
				array area = Workflow.Area.fromCache( (session.area.id ? session.area.id : 0) );
				if( area.openExternalSettings ){
					object openExternal = Workflow.OpenExternalSettings.tiny( area.openExternalSettings.id );
					if(openExternal.url != ''){
						openExternalSystem['xwindow'] = openExternal.xwindow;
						openExternalSystem['ywindow'] = openExternal.ywindow;
						openExternalSystem['url'] = openExternal.url;
					}
				}
				
				if( !openExternalSystem.keyExists('url') ){
					array organization = Workflow.Organisation.fromCache( (area.organisationID ? area.organisationID : 0) );
					if(organization.openExternalSettings){
						object openExternal = Workflow.OpenExternalSettings.tiny( organization.openExternalSettings.id );
						if(openExternal.url != ''){
							openExternalSystem['xwindow'] = openExternal.xwindow;
							openExternalSystem['ywindow'] = openExternal.ywindow;
							openExternalSystem['url'] = openExternal.url;
						}	
					}					
				}
				
				if( openExternalSystem.keyExists('url') and session.user ){
					object user = Workflow.User.load( session.user.id );
					openExternalSystem['showOption'] = ( user.openExternalOption != '' ? user.openExternalOption : '');
				}
		}

		return JSON.valueToJSON([
			'acquired' => acquired,
			'externalData' => session.externalData,
			'messages' => (closure {
				if( acquired) {
					return ._getAllMessages(session);
				}
				return [];
			}).invoke(),
			'area' => [
				'id' => (session and session.area ? session.area.id : 0),
				'agents' => (closure {
					if( acquired ) {
						return ._getAreaAgents(session.area.id);
					}
					return [];
				}).invoke(),
				'alternativeAnswer' => (closure {
					if( acquired && F('alternative-answers.show-everything')) {
						return ._getAlternativeAnswers(session.area.id);
					}
					return [];
				}).invoke()
			],
			'OpenExternal' => openExternalSystem,
			'clientEmail' => (session.client and session.client.email ? session.client.email.emailAddress : ''),
			'tag' => (closure{
					if( Workflow.Area.tagsFromCache( session.area.id ))
						return true;
					return false;
				}).invoke(),
			'feature' => (closure{
					if( F('chat.optional-tag') ) {
							return 1;
					} else {
						if( F('chat.forced-tag') )
							return -1;
						return 0;
					}
				}).invoke()
		]);
	}
	
	function getOpenExternalPopupOption(array parameters){

		return JSON.valueToJSON( true );
	}

	function markAsSeen( array parameters ) {
		array sessions = [];
		if( parameters.keyExists('sessions') ) {
			sessions = parameters['sessions'].toArray(',');
		}
		sessions.each() using ( id ) {
			object session = Workflow.ChatSession.load(id.toNumber());
			if( session ) {
				session.setValue('hasUnseenMessages', false);
				session.save();
				Logger.info(Logger.APPLICATION_CHAT,
					"Marking session [${session.id}] owned by ${session.user.username} [${session.user.id}] as seen");
			}
		};
		return JSON.valueToJSON(true);
	}

	function fetchContacts( array parameters ) {
		string componentName = (parameters.keyExists('component') ? parameters['component'] : 'GlobalChat');
		number tab = (parameters.keyExists('tab') ? parameters['tab'].toNumber() : 1);
		number page = (parameters.keyExists('page') ? parameters['page'].toNumber() : 0);
		boolean answered = (parameters.keyExists('answered') ? (parameters['answered'].toNumber() ? true : false) : true);
		boolean unanswered = (parameters.keyExists('unanswered') ? (parameters['unanswered'].toNumber() ? true : false) : true);
		string address = parameters['address'];
		
		if( address ) {
			Workflow.Errand.OtherContactsComponent = componentName;
			Workflow.Errand.OtherContactsTab = 'chat-contacts-tab';
			Workflow.Errand.OtherContactsByDomainTab = 'chat-contacts-by-domain-tab';
			Workflow.Errand.OtherContactsShowAnswerd = 'chat-contacts-show-answered';
			Workflow.Errand.OtherContactsShowUnanswered = 'chat-contacts-show-unanswered';
			Workflow.Errand.OtherContactsPrevious = 'chat-contacts-previous';
			Workflow.Errand.OtherContactsNext = 'chat-contacts-next';
			Workflow.Errand.OtherContactsByDomainPrevious = 'chat-contacts-by-domain-previous';
			Workflow.Errand.OtherContactsByDomainNext = 'chat-contacts-by-domain-next';
			Workflow.Errand.OtherContactsOptions = 'chat-contacts-options';
			Workflow.Errand.OtherContactsContent = 'chat-contacts-content';
			Workflow.Errand.OtherContactsVarContactsTab = 'ChatContactsTab';
			Workflow.Errand.OtherContactsVarContactsPage = 'ChatContactsPage';
			Workflow.Errand.OtherContactsAddress = "'${address}'";
			Workflow.Errand.OtherContactsFireRequest = "_('${componentName}').fireCallbackRequest";
			Workflow.Errand.OtherContactsFireRequestCallback = "function( value ) { $('${componentName}_ContactsBoxContent').innerHTML = value; }";
			return '<div style="margin-bottom:10px;">' +
				Workflow.Errand.otherContactsAsHTML(null, address, answered, unanswered, tab, page) +
			'</div>';
		}
		
		return I('No Other Contact Found');
	}
	
	
		/**
	 * @function fetchTagList
	 * @declaration function fetchTagList( number id )
	 * @brief Fetch the normal and high priority tag list for a given area.
	 * @param number id The area id to load
	 * @return A keyed array with 'high' and 'normal' values, each one is a hybrid datasource for tags in that category.
	 */
	function fetchTagList( array param ) {
		string tagdisplay;
		number id = param['id'].toNumber();
		number session_id = param['session_id'].toNumber();	
			tagdisplay += "<div id='tag_list_display'>";
			Workflow.Area.tagsFromCache(id).each() using ( tag_cache ) {
				number tagid = tag_cache['id'];
				string tagval = tag_cache['display'];
				tagdisplay += "<div><input type='checkbox' name='tagcheck' id='tagcheckid${tagid}' value='${tagval}' onclick='checkOneTag(${session_id},${tagid},1)'/> ${tagval}</div>";
			};
			tagdisplay += "</div>";
		
		return tagdisplay;
	}
	
	
	function displayTagList( array parameters ) {
			number areaid = parameters['areaid'].toNumber();
			number session_id = parameters['session'].toNumber();	
			string tagdisplay;
			string tagdisplayContent = I('Are you sure you want to finish the chat without choosing a tag?');
			string yesButton = I('Yes');
			string noButton = I('No');
			if( F('chat.forced-tag') ) {
				tagdisplay += "<div id='tag_list_display'>";
			} else {
				tagdisplay = "<div id='confirm_finish' style='display: block; padding-top: 50px; padding-left: 50px;'>"+ tagdisplayContent +"</div>";
				tagdisplay += "<div id='confirm_finish_yesno' style='display: block; padding-left: 170px; padding-top: 10px; padding-bottom: 50px;'> <input type='button' onclick='finishNoTag(${session_id});' name='confirm_tag' id='confirm_tag' value = '"+ yesButton +"' /> <input type='button' onclick='displayTag();' name='confirm_notag' name='confirm_notag' value = '"+ noButton +"' /></div>";	
				tagdisplay += "<div style='display: none' id='tag_list_display'>";
			}
				Workflow.Area.tagsFromCache(areaid).each() using ( tag_cache ) {
					number tagid = tag_cache['id'];
					string tagval = tag_cache['display'];
					tagdisplay += "<div><input type='checkbox' name='tagcheck' id='tagcheckid${tagid}' value='${tagval}' /> ${tagval} </div>";
				};
				tagdisplay += "<div style='display: block; padding-left: 170px; padding-top: 10px; padding-bottom: 10px;'><input type='button' value='Finish' onclick='checkedTags(${session_id},0)'> <input type='button' value='Cancel' onclick=AnswerPageBoxClose('GlobalChat_TagsBoxFinish')></div></div>";
			return tagdisplay;
	}
	
	function finishChatSessionTag(array params){	
		string tagname = params['withTag'];	
		number sid = params['value'].toNumber();
		number tagid = params['tagid'].toNumber();
		number id = params['id'].toNumber();
		
		object session = Workflow.ChatSession.load(sid);
		if(session){
			if(tagname == 'withtag') {
			object tag = Workflow.Tag.load( tagid );
				if(id == 0)
					session.close(false, tag);
			}else{
				session.close(false, null);
			}
			if( ExternalQueueInterface.enabled() and session.queuedInExternal ) {
				ExternalQueueInterface.removeChat(session);
			}	
			return JSON.valueToJSON(true);
		}else
		{
			return JSON.valueToJSON(false);
		}
	}
	
}

namespace InternalChat {
	function handleChatRequest ( object req, array commands, array parameters ) {
	
		// Quick workaround to handle multiple requests.
		// TODO: replace global request variable with request parameter.
		request = req;
		currentUser = Workflow.User.fetchUserObject();
		//monitor {
		if( commands ) {
			switch( commands[0] ) {
				case 'MCAM': {
					array channels = [];
					
					allowedToStoreSession = false;
	
					ExternalQueueInterface.setup();
					
					GUIKit.isBackgroundEvent = true;
					req.contentType('text/json; charset=UTF-8');
					
					switch( commands[1] ) {
						case 'GlobalChat.getUpdate':
						case 'StandaloneChat.getUpdate':
							channels[] = HTML.MCAMChannel('Result', commands[1], ChatMCAM.getUpdate(parameters));
							break;
						case 'GlobalChat.sendMessage':
						case 'StandaloneChat.sendMessage':
							channels[] = HTML.MCAMChannel('Result', commands[1], ChatMCAM.sendMessage(parameters));
							break;
						case 'GlobalChat.getAgents':
						case 'StandaloneChat.getAgents':
							channels[] = HTML.MCAMChannel('Result', commands[1], ChatMCAM.getAgents(parameters));
							break;
						case 'GlobalChat.forwardToAgent':
						case 'StandaloneChat.forwardToAgent':
							channels[] = HTML.MCAMChannel('Result', commands[1], ChatMCAM.forwardToAgent(parameters));
							break;
						case 'GlobalChat.forwardToArea':
							channels[] = HTML.MCAMChannel('Result', commands[1], ChatMCAM.forwardToArea(parameters));
							break;
						case 'GlobalChat.getAlternativeAnswers':
							channels[] = HTML.MCAMChannel('Result', commands[1], ChatMCAM.getAlternativeAnswers(parameters));
							break;	
						case 'GlobalChat.getOpenExternalPopupOption':
						case 'StandaloneChat.getOpenExternalPopupOption':
							channels[] = HTML.MCAMChannel('Result', commands[1], ChatMCAM.getOpenExternalPopupOption(parameters));
							break;
						case 'GlobalChat.finishSession':
						case 'StandaloneChat.finishSession':
							channels[] = HTML.MCAMChannel('Result', commands[1], ChatMCAM.finishSession(parameters));
							break;
						case 'GlobalChat.displayTagList':
						case 'StandaloneChat.displayTagList':
							channels[] = HTML.MCAMChannel('Result', commands[1], ChatMCAM.displayTagList(parameters));
							break;
						case 'GlobalChat.acquireSession':
						case 'StandaloneChat.acquireSession':
							channels[] = HTML.MCAMChannel('Result', commands[1], ChatMCAM.acquireSession(parameters));
							break;
						case 'GlobalChat.markAsSeen':
						case 'StandaloneChat.markAsSeen':
							channels[] = HTML.MCAMChannel('Result', commands[1], ChatMCAM.markAsSeen(parameters));
							break;
						case 'GlobalChat.fetchContacts':
						case 'StandaloneChat.fetchContacts':
							channels[] = HTML.MCAMChannel('Result', commands[1], ChatMCAM.fetchContacts(parameters));
							break;
						case 'GlobalChat.fetchTagList':
						case 'StandaloneChat.fetchTagList':
							channels[] = HTML.MCAMChannel('Result', commands[1], ChatMCAM.fetchTagList(parameters));
							break;
						case 'GlobalChat.finishChatSessionTag':
						case 'StandaloneChat.finishChatSessionTag':
							channels[] = HTML.MCAMChannel('Result', commands[1], ChatMCAM.finishChatSessionTag(parameters));
							break;
					}
					
					return HTML.MCAMEnvelope(channels.join(','));
				}
				default:
					return "";
	
			}
		}
		/*}
		handle {
			Console.println("\033[41;33m##########[ERROR]##########\033[0m");
			Console.print("\033[31m");
			Console.println(err.str);
			Console.println(err.stack);
			Console.println("\033[0m");
			Console.println("\n\n");
			return "";
		}*/
	}
}

