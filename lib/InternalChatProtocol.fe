uses 'chatqueue/chatqueue';
uses 'asyncJsonRPC';
uses '/cention/webroot/Cention.app/Support/Pages/CentionBase';

global {
	object currentChatUser;
}

namespace ChatMCAM {
	function init {
		currentChatUser = Workflow.User.fetchUserObject();
		Workflow.FeatureSystem.setup();
		ExternalQueueInterface.setup();
	}

	function _getAreaAgents( number area_id ) {
		return Array.append( [ [ 'id' => 0, 'value' => I('Forward To Agent') ] ], (closure {
			array list = [];
			Workflow.User.listFromCache(area_id).each() using ( item ) {
				if( item['id'] != currentChatUser.id ) {
					object user = Workflow.User.load(item['id']);
					if( user and user.acceptChat ) {
						list[] = item;
					}
				}
			};
			return list;
		}).invoke());
	}
	function _getAlternativeAnswers( number area_id ) {
			array list = [];
			array data = [];
			array results = [];
			array result = [];
			string body = '';
			
			object area = Workflow.Area.load( area_id );
			if( area ) {
				object searchRules = area.getExternalSearchRules();
				if( searchRules and searchRules.enabled and ExternalSearchInterface.isEnabled() ) {
					results = ExternalSearchInterface.templates(searchRules, true);
				} else {
					results = Workflow.Search.run("custom:answer locations:${area.id} type:contents-keyword source:either state:any published:yes exact:no time:both sort-asc:subject limit:1000 offset:0");
				}
			}
			result['order'] = [];
			result['list'] = [];
			results.each() using ( row ) {
				if( row['body'] ){

					if( row['body'].utf8Length() > 50)
						body = row['body'].utf8Slice(50) + '...';
					else
						body = row['body'];

					result['order'][] = row['id'];
					result['list']['' + row['id']] = [
						'id' => row['id'],
						'data' => [ 
							'left_arrow' => '<img src="{0}" onclick="_publishedAnswerCopyTo({1})" style="vertical-align:top;background-color: #FCAB46; cursor: pointer;" border="0" />'.expand( uriForImageResource('submit_arrow_left.png'), row['id']),
							'subject' => row['subject'],
							'body' => body,
							'trimBody' => row['body']
						]
					];
				}
			};
			return [ 'list' => result, 'data' => data ];
	}
	function _messageToArray( object message ) {
		return [
			'id' => message.id,
			'sender' => (message.user
				? (message.user.chatName
					? message.user.chatName
					: message.user.username
					)
				: (message.client
					? message.client.name
					: I('System')
					)
				),
			'body' => ._formatBody(message.message),
			'sent' => message.timestampSent,
			'sentHuman' => formatTime(message.timestampSent),
			'colour' => (message.user ? '#0000FF' : '#FF0000')
		];
	}
	
	function _formatBody( string body ) {
		object r = new Regexp('(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])', 'i');

		body = r.replaceAll(body) using ( match ) {
			return Regexp.replaceAll('\/', match.match(), '___SLASH___');
		};
		body = r.replaceAll(body) using ( match ) {
			return Regexp.replaceAll('&', match.match(), '___AMPERSAND___');
		};

		body = Regexp.replaceAll('<', body, '&lt;');
		body = Regexp.replaceAll('>', body, '&gt;');
		body = Regexp.replaceAll('"', body, '&quot;');
		body = Regexp.replaceAll("'", body, '&#x27;');
		body = Regexp.replaceAll('/', body, '&#x2F;');
		body = Regexp.replaceAll('&', body, '&amp;');

		body = Regexp.replaceAll('___SLASH___', body, '/');
		body = Regexp.replaceAll('___AMPERSAND___', body, '&');

		body = r.replaceAll(body, '<a style="color:#333399;" target="_blank" href="\1">\1</a>');

		return body;
	}
	
	function _getList( array area_ids, array user_ids) {
		array list = [];
		array order = [];
		array sessions = [];
		array totalList = [];
		array activeList = Workflow.ChatSession.activeList(Workflow.SystemGroup.current(), area_ids, user_ids);
		array visibleList = Workflow.ChatSession.visibleList(Workflow.SystemGroup.current(), area_ids, user_ids);
		array chats = [];
		string sqlQuery = "select a.session,message,clientsentlast from (
				select distinct on (session) session, client_fkey != 0 as clientsentlast
					from workflow_chatmessages
						where session in (%SESSIONS%)
						order by session,timestampsent desc
			) as a join (
				select distinct on (session) session, message
					from workflow_chatmessages
						where session in (%SESSIONS%)
						and client_fkey != 0
						order by session,timestampsent desc
			) as b on a.session = b.session;";
		totalList = activeList.append(visibleList);
		if (totalList.size() > 0) {
			totalList.each() using ( session ) {
				sessions.push(session.id);
			};
			
			ObjRunObject.rawQuery(sqlQuery.replace('%SESSIONS%',sessions.join(','))).each() using ( chat ) {
				chats["${chat.session}"] = [
					'session' => chat.session,
					'message' => chat.message,
					'clientSentLast' => chat.clientsentlast
				];
			};
			
			totalList.each() using ( session ) {
				array chat = (chats.keyExists("${session.id}") ? chats["${session.id}"] : []);
				
				order[] = session.errand.id;
				list["${session.id}"] = [
					'id' => session.errand.id,
					'chatSessionID' => session.id,
					'visible' => session.visible,
					'data' => [
						'id' => session.errand.id,
						'areaID' => session.area.id,
						'area' => session.area.name,
						'message' => (chat and chat.message
							? (chat.message.utf8Length() > 125 ? ._formatBody(chat.message.utf8Slice(125)) + '...' : ._formatBody(chat.message))
							: I('No Message')),
						'client' => (session.client and session.client.name ? ._formatBody(session.client.name) : I('No Name')),
						'email' => (session.client and session.client.email ? ._formatBody(session.client.email.emailAddress) : I('No Sender')),
						'assigned' => (session.user ? 1 : 0),
						'owner' => (session.user ? session.user.username : I('Unassigned')),
						'startedHuman' => formatDateTime(session.timestampStarted),
						'started' => session.timestampStarted
					],
					'style' => [
						'bg' => (session.user and session.user.id == currentChatUser.id ? '#CFC' : '#FFF'),
						'bold' => (chat and chat.clientSentLast == 't' ? true : false)
					]
				];
			};
		}
	
		return [
			'list' => list,
			'order' => order
		];
	}

	function _getAllMessages( object session ) {
		array list = [];
		Workflow.ChatMessage.listBySession(session.id).each() using ( message ) {
			list[] = ._messageToArray(message);
		};
		if( session.clientReportedAsInactive ) {
			string clientName = (session.client ? ._formatBody(session.client.name) : I('No Name'));
			list[] = [
				'id' => 0,
				'sender' => I('System'),
				'body' => I('{0} has become inactive and most likely closed the chat window.').expand(clientName),
				'sent' => session.timestampClientReportedAsInactive,
				'sentHuman' => formatTime(session.timestampClientReportedAsInactive),
				'colour' => '#000000'
			];
			list = list.sort() using ( a, b ) {
				if( a['sent'] < b['sent'] ) return -1;
				if( a['sent'] == b['sent'] ) return 0;
				if( a['sent'] > b['sent'] ) return 1;
			};
		}
		return list;
	}
	
	function _getMessages( number sessionID, number timestampLastMessage ) {
		array list = [];
		Workflow.ChatMessage.listBySessionAfterTimestampOnlyFromClient(sessionID, timestampLastMessage).each() using ( message ) {
			list[] = ._messageToArray(message);
		};
		if( not list ) {
			object session = Workflow.ChatSession.load(sessionID);
			if( not session.active ) {
				if( not session.clientReportedAsOffline ) {
					string clientName = (session.client ? ._formatBody(session.client.name) : I('No Name'));
					list[] = [
						'id' => 0,
						'sender' => I('System'),
						'body' => I('{0} has closed the chat window.').expand(clientName),
						'sent' => session.timestampEnded,
						'sentHuman' => formatTime(session.timestampEnded),
						'colour' => '#000000'
					];
					session.setValue('clientReportedAsOffline', true);
					session.save();
				}
			} else {
				// If we have not received any new messages from the client
				// we check if the client has become inactive.
				
				if( not session.clientReportedAsInactive ) {
					number now = Date.GMTnow();
					number timeout = (F('chat.inactive-timeout') ? F('chat.inactive-timeout') : 1);
					number timeoutSeconds = timeout * 60;
					number watermark = now - timeoutSeconds;
					
					if( session.timestampLastClientUpdate <= watermark ) {
						// If we get here we consider the client to have become inactive.
						// It is time to display a message.
						string clientName = (session.client ? ._formatBody(session.client.name) : 'No Name');
						list[] = [
							'id' => 0,
							'sender' => I('System'),
							'body' => I('{0} has become inactive and most likely closed the chat window.').expand(clientName),
							'sent' => now,
							'sentHuman' => formatTime(now),
							'colour' => '#000000'
						];
						session.setValue('clientReportedAsInactive', true);
						session.setValue('timestampClientReportedAsInactive', now);
						session.save();
					}
				}
			}
		}
		return list;
	}
	
	boolean _attemptedActiveSessionsCache = false;
	array _activeSessionsCache;
	function _getActiveSessionsForCurrentUser() {
		if( not ._attemptedActiveSessionsCache ) {
			._activeSessionsCache = [];
			Workflow.ChatSession.activeList(Workflow.SystemGroup.current(), Workflow.Area.idListForUserFromCache(),
				[ currentChatUser.id ]).each() using ( session )
			{
				._activeSessionsCache[] = session.id;
			};
		}
		return ._activeSessionsCache;
	}
	
	function _getUnseenSessions() {
		array sessionsWithUnseenMessages;
		object sessionToShow;
		sessionsWithUnseenMessages = Workflow.ChatSession.haveUnseenMessagesList(Workflow.SystemGroup.current(), currentChatUser.id);
		if( sessionsWithUnseenMessages ) {
			sessionToShow = sessionsWithUnseenMessages[0];
			Logger.info(Logger.APPLICATION_CHAT,
				"Sending unseen sessions [" + sessionsWithUnseenMessages.join(', ') using( session ) { return session.id; } +
				"] to ${currentChatUser.username} [${currentChatUser.id}]");
		}
		if( sessionToShow ) {
			return [
				'list' => sessionsWithUnseenMessages.process() using( session ) { return session.id; },
				'session' => [
					'id' => (sessionToShow.errand and sessionToShow.errand.id ? sessionToShow.errand.id : 0 ),
					'chatSessionID' => sessionToShow.id, 
					'client' => (sessionToShow.client and sessionToShow.client.name ? sessionToShow.client.name : I('No Name')),
					'messages' => ._getAllMessages(sessionToShow),
					'area' => [
						'id' => (sessionToShow.area ? sessionToShow.area.id : 0)
					],
					'user' => [
						'openExternalSystem' => currentChatUser.openExternalSystem
					]
				]
			];
		}
		return null;
	}

	function getUpdate( array parameters ) {
		number session_id = 0;
		array area_ids = [];
		array user_ids = [];
		number current_time = Date.GMTnow();
		number blockchat_minutes = (F('chat.blacklist.time') ? F('chat.blacklist.time') : 0);
		number blockchat_seconds = blockchat_minutes * 60;
		
		if( currentChatUser.acceptChat ) {
			Logger.info(Logger.APPLICATION_CHAT, "Update -> ${currentChatUser.username} [${currentChatUser.id}] - time since last update: " + (closure {
				return Date.GMTnow() - currentChatUser.timestampLastChatUpdate;
			}).invoke() + " (${Date.GMTnow()})");
		}
		currentChatUser.setValue('timestampLastChatUpdate', Date.GMTnow());
		currentChatUser.save();
		area_ids = Workflow.Area.idListForUserFromCache();
		
		if(blockchat_minutes != 0) 	{
				area_ids.each() using ( areaids ) {
					Workflow.BlockedIPAddress.getIpAddressBlacklist( areaids ).each() using ( iplist ) {
							object iplAdddress = Workflow.BlockedIPAddress.load(iplist.id);
							if(current_time - iplAdddress.timestampWhen > blockchat_seconds)	{
								iplAdddress.setValue('active', false);
								iplAdddress.save();
							}								
					};
				};
		}
		
		if( parameters.keyExists('session') ) {
			session_id = parameters['session'].toNumber();
		}
		
		return JSON.valueToJSON([
			'list' => ._getList(area_ids, [currentChatUser.id]),
			'current' => (closure {
				object session = Workflow.ChatSession.load(session_id);
				if( session ) {
					return [
						'client' => (session.client and session.client.name ? session.client.name : I('No Name')),
						'clientEmail' => (session.client and session.client.email ? ._formatBody(session.client.email.emailAddress) : ''),
						'preview' => ._formatBody(session.nextClientMessagePreview),
						'showMessagePreview' => ( session.user && session.user.chatMessagePreview ? session.user.chatMessagePreview : 0 ),
						'messages' => ._getMessages(session.id, (parameters.keyExists('timestampLastMessage')
							? parameters['timestampLastMessage'].toNumber()
							: 0)),
						'tag' => (Workflow.Area.tagsFromCache( session.area.id ) ? true : false)					
					];
				}
				return null;
			}).invoke(),
			'feature' => (closure{
					if( F('chat.forced-tag') ) {
							return 1;
					} else {
						if( F('chat.optional-tag') )
							return -1;
						return 0;
					}
				}).invoke(),
			'unseen' => ._getUnseenSessions(),
			'count' => ._getActiveSessionsForCurrentUser().size()
		]);
	}
	
	function sendMessage( array parameters ) {
		object session = Workflow.ChatSession.load( (parameters.keyExists('session') ? parameters['session'].toNumber() : 0));
		if( session ) {
			number now = Date.GMTnow();
			object message = new Workflow.ChatMessage();
			message.setValue('session', session.id);
			message.setValue('timestampSent', now);
			message.setValue('message', parameters['text']);
			message.setValue('user', currentChatUser);
			message.save();
			if( now > session.timestampLastAgentMessageSent ) {
				session.setValue('timestampLastAgentMessageSent', now);
				session.save();
			}
			return JSON.valueToJSON(true);
		}
		return JSON.valueToJSON(false);			
	}
	
	function getAgents( array parameters ) {
		object session = Workflow.ChatSession.load( (parameters.keyExists('session') ? parameters['session'].toNumber() : 0));
		if( session ) {
			object area = Workflow.Area.load( session.area.id ); // Tiny to full
			if( ExternalQueueInterface.enabled() and (area.externalID or area.solidusServiceGroupID) ) {
				array list = ExternalQueueInterface.getChatAgents(area);
				list.unshift([ 'id' => 0, 'value' => I('Forward to Agent') ]);
				return JSON.valueToJSON(list);
			} else {
				return JSON.valueToJSON(._getAreaAgents(area.id));
			}
		} else {
			return JSON.valueToJSON([]);
		}
	}

	function forwardToAgent( array parameters ) {
		number now = Date.GMTnow();
		object session = Workflow.ChatSession.load( (parameters.keyExists('session') ? parameters['session'].toNumber() : 0));
		object user = Workflow.User.load((parameters.keyExists('forward')
			? parameters['forward'].toNumber()
			: 0));
		object fromUser = Workflow.User.load( (session.user.id ? session.user.id : 0));
		
		if( session and user ) {
			object area = session.area;
			if( ExternalQueueInterface.enabled() and (area.externalID or area.solidusServiceGroupID) ) {
				if( ExternalQueueInterface.forwardChatToAgent(session, user) ) {
					// The chat is set to have unseen messages so that it is automatically
					// shown to the agent it is forwarded to.
					session.setValue('hasUnseenMessages', true);
					session.setValue('user', null);
					session.setValue('fromAgent', null);
					session.setValue('status', Workflow.ChatSession.STATUS_WAITING_ON_AGENT);
					session.save();
					return JSON.valueToJSON(true);
				}
			} else {
				// The chat is set to have unseen messages so that it is automatically
				// shown to the agent it is forwarded to.
				session.setValue('hasUnseenMessages', true);
				session.setValue('user', user);
				session.setValue('fromAgent', fromUser);
				session.setValue('timestampForward', now);
				session.save();
				return JSON.valueToJSON(true);
			}
		}
		return JSON.valueToJSON(false);
	}
	
	function forwardToArea( array parameters ) {
		object session;
		object toArea;
		number now = Date.GMTnow();
		object fromUser;
		object fromArea;
		if( parameters.keyExists('forward_area_id') or parameters.forward_area_id != 0 ) {
			toArea = Workflow.Area.tiny( parameters.forward_area_id.toNumber() );
			session = Workflow.ChatSession.load( (parameters.keyExists('session') ? parameters['session'].toNumber() : 0));
			fromUser = Workflow.User.tiny( (session.user.id ? session.user.id : 0) );
			fromArea = Workflow.Area.tiny( (session.area.id ? session.area.id : 0) );
			
			if( ChatQueueInterface.isOpen( toArea ) ){
				//session.area need to change because session area should be updated with 
				// forward area ID.
				session.area = toArea;
				if( ChatQueueInterface.addChat( session ) ){
					session.setValue('area', toArea);
					session.setValue('fromAgent', fromUser);
					session.setValue('timestampForward', now);
					session.setValue('fromArea', fromArea);
					session.save();
					Logger.info(Logger.APPLICATION_CHAT, "Chat Session [${session.id}] successfully forwarded to Area [${parameters.forward_area_id}]");

					return JSON.valueToJSON(true);			
				}else{
					Logger.info(Logger.APPLICATION_CHAT, "Forward to area not possible at the moments. Possibly no agents available.");
					return JSON.valueToJSON(false);
				}
			}
		}
		return JSON.valueToJSON(false);
	}
	
	function sendChatHistoryEmailToClient( object session ){
		object bodyContents = null;
		string to = (session.client && session.client.email ? session.client.email.emailAddress : '');
		object logClosure = closure ( string text ) {};
		object connection = new Mail.Connection();
		object to_addr = new Mail.Address( to );
		object from_addr;
		bodyContents = (closure{
			string body = "";
			string htmlBody;
			object message = new Mail.Message();
			object text = new Mail.MessagePart();
			object area = Workflow.Area.load(session.area.id);
			array messages = Workflow.ChatMessage.listBySession( session.id );
			from_addr = new Mail.Address( area.replyToEmailAddress );
			message.header = new Mail.MessageHeader();
			message.header.from.add( from_addr );
			message.header.to.add(to_addr); 		
			message.header.subject = I('Chat history');
			message = MailUtilities.setOutgoingHeader(message, area.replyToEmailAddress);
			messages.each() using ( content ) {
				string sender = (content.user
								? (content.user.chatName ? content.user.chatName : content.user.username)
								: (session.client ? session.client.name : I('No Name'))
								);
				body += "(${formatDateTime(content.timestampSent)}) ${sender}: ${content.message}\r\n";
			};
			body = Regexp.replaceAll("\r\n", body, "\n");
			body = Regexp.replaceAll("\r", body, "\n");
			body = Regexp.replaceAll("\n", body, "\r\n");

			text.type = Mail.Mime.TYPETEXT;
			text.subtype = "plain";
			text.charset = "UTF-8";
			text.content = body;
			message.content = text;
			return message;
		}).invoke();

		if( MailUtilities.sendMessage(connection, bodyContents, logClosure) ) {
			Logger.info(Logger.APPLICATION_CHAT, "- Chat history email to [${to}] Done.");
		} else {
			Logger.info(Logger.APPLICATION_CHAT,"!! Failed chat history to send in email.");
		}
	}

	function finishSession( array parameters ) {
		object session = Workflow.ChatSession.load( (parameters.keyExists('session') ? parameters['session'].toNumber() : 0));
		boolean sessionVisible = ( parameters.keyExists('visible' ) ? parameters['visible'].toBoolean() : false);
		if( sessionVisible ){
			session.setValue('visible',false );
			session.save();
			Logger.info(Logger.APPLICATION_CHAT,"Chat session [${session.id}] has invisible.");
			return JSON.valueToJSON([ 'status' => 0]);
		}else{
			if( session ) {
				session.close(false, false);
				ChatQueueInterface.endChat(session);
				Logger.info(Logger.APPLICATION_CHAT, "Chat session [${session.id}] has successfully closed.");
				if( F('chat.history-send-to-client') ){
					monitor{
						.sendChatHistoryEmailToClient( session );
					}handle{
						Logger.info(Logger.APPLICATION_CHAT, "!! Unable to send email: ${err.str.trim("\n")}");
					}
				}
				return JSON.valueToJSON(['status' => 1]);
			}
		}
		Logger.info(Logger.APPLICATION_CHAT, "Trying to close the chat session [${parametes[0]}], failure!");
		return JSON.valueToJSON(['status' => 2]);
	}
	
	function acquireSession( array parameters ) {
		number errandId = (parameters.keyExists('session') ? parameters['session'].toNumber() : 0);
		object chatSession = Workflow.ChatSession.chatSessionByErrandID( errandId );
		object session = Workflow.ChatSession.load( chatSession.id );
		boolean acquired = false;
		object organisation = Workflow.Organisation.byAreaID( session.area.id );
		
		// Workflow.Organisation.byAreaID() returns organisation object of view Tiny.
		// More data is needed so full object is loaded.
		organisation = Workflow.Organisation.load( organisation.id );
		if( session and session.user and session.user.id == currentChatUser.id ) {
			acquired = true;
		} else if( session and session.user == null ) {
			session.setValue('user', currentChatUser);
			session.setValue('timestampAssigned', Date.GMTnow());
			session.save();
			acquired = true;
		}

		return JSON.valueToJSON([
			'acquired' => acquired,
			'chatSessionID' => session.id,
			'externalData' => session.externalData,
			'startedHuman' => formatDateTime(session.timestampStarted),
			'messages' => (closure {
				if( acquired) {
					return ._getAllMessages(session);
				}
				return [];
			}).invoke(),
			'area' => [
				'id' => (session and session.area ? session.area.id : 0),
				'name' => (session and session.area ? session.area.name : ''),
				'organisation' => ( organisation ? organisation.name : ''),
				'answers' => (closure {
					if( acquired && F('alternative-answers.show-everything')) {
						return ._getAlternativeAnswers( session.area.id );
					}
					return [];
				}).invoke(),
				'externalSystemURL' => (closure {
					if( acquired ) {
						// The area object in Workflow.ChatSession is of view Tiny.
						// This means that it does not contain the variables that are needed here.
						// That is why the full area object is loaded.
						object area = Workflow.Area.load(session.area.id);
						if( area.openExternalSystemRules ) {
							return area.openExternalSystemRules.url;
						} else {
							if( organisation.openExternalSystemRules )
								return organisation.openExternalSystemRules.url;
						}
					}
					return '';
				}).invoke()
			],
			'user' => [
				'openExternalSystem' => currentChatUser.openExternalSystem
			],
			'client' => (session.client and session.client.name ? ._formatBody(session.client.name) : I('No Name')),
			'clientEmail' => (session.client and session.client.email ? ._formatBody(session.client.email.emailAddress) : ''),
			'tag' => (closure{
					if( Workflow.Area.tagsFromCache( session.area.id ))
						return true;
					return false;
				}).invoke(),
			'feature' => (closure{
					if( F('chat.forced-tag') ) {
							return 1;
					} else {
						if( F('chat.optional-tag') )
							return -1;
						return 0;
					}
				}).invoke(),
			'errand_notes' => ._getErrandNotes( errandId ),
			'client_notes' => ._getClientNotes( errandId ),
			'ipaddress' =>  session.ipAddress
		]);
	}

	function markAsSeen( array parameters ) {
		array sessions = [];
		if( parameters.keyExists('sessions') ) {
			sessions = parameters['sessions'].toArray(',');
		}
		sessions.each() using ( id ) {
			object session = Workflow.ChatSession.load(id.toNumber());
			if( session ) {
				session.setValue('hasUnseenMessages', false);
				session.save();
				Logger.info(Logger.APPLICATION_CHAT,
					"Marking session [${session.id}] owned by ${session.user.username} [${session.user.id}] as seen");
			}
		};
		return JSON.valueToJSON(true);
	}

	function fetchContacts( array parameters ) {
		string componentName = (parameters.keyExists('component') ? parameters['component'] : 'GlobalChat');
		number tab = (parameters.keyExists('tab') ? parameters['tab'].toNumber() : 1);
		number page = (parameters.keyExists('page') ? parameters['page'].toNumber() : 0);
		boolean answered = (parameters.keyExists('answered') ? (parameters['answered'].toNumber() ? true : false) : true);
		boolean unanswered = (parameters.keyExists('unanswered') ? (parameters['unanswered'].toNumber() ? true : false) : true);
		string address = parameters['address'];
		if( address ) {
			Workflow.Errand.OtherContactsComponent = componentName;
			Workflow.Errand.OtherContactsTab = 'chat-contacts-tab';
			Workflow.Errand.OtherContactsByDomainTab = 'chat-contacts-by-domain-tab';
			Workflow.Errand.OtherContactsShowAnswerd = 'chat-contacts-show-answered';
			Workflow.Errand.OtherContactsShowUnanswered = 'chat-contacts-show-unanswered';
			Workflow.Errand.OtherContactsPrevious = 'chat-contacts-previous';
			Workflow.Errand.OtherContactsNext = 'chat-contacts-next';
			Workflow.Errand.OtherContactsByDomainPrevious = 'chat-contacts-by-domain-previous';
			Workflow.Errand.OtherContactsByDomainNext = 'chat-contacts-by-domain-next';
			Workflow.Errand.OtherContactsOptions = 'chat-contacts-options';
			Workflow.Errand.OtherContactsContent = 'chat-contacts-content';
			Workflow.Errand.OtherContactsVarContactsTab = 'ChatContactsTab';
			Workflow.Errand.OtherContactsVarContactsPage = 'ChatContactsPage';
			Workflow.Errand.OtherContactsAddress = "'${address}'";
			Workflow.Errand.OtherContactsFireRequest = "_('${componentName}').fireCallbackRequest";
			Workflow.Errand.OtherContactsFireRequestCallback = "function( value ) { $('${componentName}_ContactsBoxContent').innerHTML = value; }";
			return '<div style="margin-bottom:10px;">' +
				Workflow.Errand.otherContactsAsHTML(null, address, answered, unanswered, tab, page) +
			'</div>';
		}
		
		return I('No Other Contact Found');
	}
	
	
		/**
	 * @function fetchTagList
	 * @declaration function fetchTagList( number id )
	 * @brief Fetch the normal and high priority tag list for a given area.
	 * @param number id The area id to load
	 * @return A keyed array with 'high' and 'normal' values, each one is a hybrid datasource for tags in that category.
	 */
	function fetchTagList( array param ) {
		string tagdisplay;
		number id = param['id'].toNumber();
		number session_id = param['session_id'].toNumber();
			tagdisplay += "<div id='tag_list_display'><div style='height: 200px; overflow: auto;'><ul>";
			Workflow.Area.tagsFromCache( id ).each() using ( tag_cache ) {
				number tagid = tag_cache['id'];
				string tagval = tag_cache['display'];
				if( not tag_cache['forDelete']  ){
				tagdisplay += "<li id='chattag_itemslists'><input type='checkbox' name='tagchecks' id='tagcheckids${tagid}' value='${tagval}' onclick='checkOneTag(${session_id},${tagid},1)'/><label> ${tagval}</label></li>";
				}
			};
			tagdisplay += "</ul></div></div>";
		return tagdisplay;
	}
	function displayTagList( array parameters ) {
			number areaid = parameters['areaid'].toNumber();
			number session_id = parameters['session'].toNumber();	
			string tagdisplay;
			tagdisplay += "<div id='tag_list_display'><div style='padding:5px'><h3 style='margin:0;padding:0'>"+I('You have not chosen a classification for this errand.')+"</h3></div><div style='padding:5px'>"+I('You can navigate the list by pressing the up and down arrows and select a classification by pressing space.')+"</div><div style='padding:5px'>"+I('Press Escape to Cancel')+"</div><div style='height: 200px; overflow: auto;'><ul>";
			Workflow.Area.tagsFromCache(areaid).each() using ( tag_cache ) {
				number tagid = tag_cache['id'];
				string tagval = tag_cache['display'];
				if( not tag_cache['forDelete']  ){
					tagdisplay += "<li id='chattag_itemslists'><input type='checkbox' name='tagcheck' id='tagcheckid${tagid}' value='${tagval}' /><label> ${tagval}</label></li>";
				}
			};
			tagdisplay += "</ul></div></div>";
			return tagdisplay;
	}
	
	function finishChatSessionTag( array params ){	
		string tagname = params['withTag'];	
		number id = params['id'].toNumber();
		number errandId = (params.keyExists('value') ? params['value'].toNumber() : 0);
		object chatSession = Workflow.ChatSession.chatSessionByErrandID( errandId );
		object session = Workflow.ChatSession.load( chatSession.id );
		object errand = Workflow.Errand.load( errandId );
		array tags = [];
		object tag;
		array  tagIDs = ((params['tagid'] isa array) ? params['tagid'] : [params['tagid']]);
		if(session){
				if(tagname == 'withtag') {
					tagIDs.each() using ( tagid ){
						tag = Workflow.Tag.load( tagid.toNumber() );
						errand.setValue('tags', errand.tags.addObject( tag ));
						errand.save();
					};
				}else{
					errand.setValue('tags', null);
					errand.save();
				}
			return JSON.valueToJSON(true);
		}	
		return JSON.valueToJSON(false);
	}
	
	function blockIPAddress( array params )	{	
			string ipaddress = params['ip'];
			number errandId = params['errand'].toNumber();
			string email = params['email'];
			number date_now = Date.GMTnow();
			object blacklist;
			object chatsession;
			object area;
					
			chatsession = Workflow.ChatSession.loadSessionByErrand( errandId );
			
			blacklist = new Workflow.BlockedIPAddress();
			blacklist.setValue('ipAddress', "${ipaddress}");
			blacklist.setValue('timestampWhen', date_now);
			blacklist.setValue('active', true);
			blacklist.setValue('area', chatsession.area);
			blacklist.setValue('user', chatsession.user);
			blacklist.setValue('email', "${email}");
			blacklist.save();
			
			if( F('chat.forced-tag'))
				return 'forcedtag';
			else if ( F('chat.optional-tag'))
				return 'optionaltag';
			else
				return 'none';	
	}
	
	function checkFeature() {
		if( F('chat.forced-tag'))
			return 'forcedtag';
		else if ( F('chat.optional-tag'))
			return 'optionaltag';
		else
			return 'none';			
	}
	function chatAnswerSearch( array parameters ) {
		array area_list = [];
		array seenList = [];
		array result = [];
		array results = [];
		string body = '';

		number filterList = parameters['filterList'].toNumber();
		string term = parameters['search_term'];

		if( filterList > 0 ) {
		area_list = [ filterList ];
		} else if( filterList <= 0 ) {
		area_list = Workflow.Area.idListForUser();
		}

		result['order'] = [];
		result['list'] = [];
		Workflow.Search.run("custom:answer locations:${area_list.join(',')} type:contents-keyword source:either state:any published:yes $term exact:no time:both sort-asc:subject limit:100 offset:0").each() using ( row ) {
			if( row['body'] ) {
				if( row['body'].utf8Length() > 50)
					body = row['body'].utf8Slice(50) + '...';
				else
					body = row['body'];

				result['order'][] = row['id'];
				result['list']['' + row['id']] = [
				'id' => row['id'],
				'data' => [
					'area' => 'All',
					'left_arrow' => '<img src="{0}" onclick="_publishedAnswerCopyTo({1})" style="vertical-align:top;background-color: #FCAB46; cursor: pointer;" border="0" />'.expand( uriForImageResource('submit_arrow_left.png'), row['id']),
					'subject' => row['subject'],
					'body' => body,
					'trimBody' => row['body']
					]
				];
			}
		};
		return JSON.valueToJSON( result );
	}
	function createNoteAttachments( object note, array attachments ) {
		array list = [];
		
		string note_id = '' + note.id;
		string path_id = note_id.blocks(1).join('/') + '/' + note_id;
		string attachmentsDirectory = (Config.CachePath - 'Cache/') + 'Workflow/Note-attachments/' + path_id + '/';
		string uploadsDirectory = (Config.CachePath - 'Cache/') + 'Workflow/Temporary-uploads/';
		
		Directory.build(attachmentsDirectory);
		GUIKit.loadComponent('BackgroundFileUploader');
		attachments.eachWithIndex() using ( id, index ) {
			string localName = 'file-' + index;
			string newPath = attachmentsDirectory + localName;
			object attachment;
			object file = new GUIKit.BackgroundFileUploaderUploadedFile(id, uploadsDirectory);
			
			file.moveTo(newPath);
			
			attachment = new Workflow.NoteAttachment();
			attachment.setValue('localPath', newPath);
			attachment.setValue('localName', localName);
			attachment.setValue('fileName', file.name);
			attachment.save();
			
			list[] = attachment;
		};
		
		return list;
	}
	function saveNote( array parameters ) {
		array notes;
		array list;
		object errandView;
		object note;
		object client;
		object thread = new Workflow.Thread();
		string type = parameters['type'];
		number errand = parameters['errand'].toNumber();
		string text = parameters['text'];
		string attachments = parameters['attachments'];
		array attachment = attachments.dissect(',');
		switch( type ) {
			case 'errand':
				errandView = Workflow.Errand.loadThreadView( errand );
				if( errandView ) {
					object notesView;
					if( not errandView.thread ) {
						thread.setValue("errands", [errandView]);
						errandView.setValue("thread",thread);
						thread.save();
						errandView.save();
					}
					notesView = Workflow.Thread.loadNotesView( (errandView.thread ? errandView.thread.id : 0) );
					if( notesView ) {
						note = new Workflow.Note();
						note.setValue('writer', currentChatUser);
						note.setValue('timestampWritten', Date.GMTnow());
						note.setValue('note', text);
						note.save();
						if( attachments ) {
							note.setValue('attachments', .createNoteAttachments(note, attachment));
							note.save();
						}
						notesView.setValue('notes', notesView.notes.addObject(note));
						notesView.save();
					}
				}
				break;
			case 'client':
				errandView = Workflow.Errand.loadClientView( errand );
				if( not errandView.client ) {
					client = new Workflow.Person(); //Empty client
					client.save();
					errandView.setValue('client', client);
					errandView.save();
				}
				if( errandView and errandView.client ) {
					note = new Workflow.Note();
					note.setValue('writer', currentChatUser);
					note.setValue('timestampWritten', Date.GMTnow());
					note.setValue('note', text);
					note.save();
					if( attachments ) {
						note.setValue('attachments', .createNoteAttachments(note, attachment));
						note.save();
					}
					errandView.client.setValue('notes', errandView.client.notes.addObject(note));
					errandView.client.save();
				}
				break;
		}
		if( note ) {
			return JSON.valueToJSON([
				'note' => [
					'id' => note.id
				]
			]);
		} else {
			return JSON.valueToJSON([
				'error' => true
			]);
		}
	}

	function removeNote( array parameters ) {
		array notes;
		array list;
		object errandThread;
		object n;
		string type = parameters['type'];
		number errand = parameters['errand'].toNumber();
		number note = parameters['note'].toNumber();
		switch( type ) {
			case 'errand':
				errandThread = Workflow.Errand.loadThreadView(errand);
				if( errandThread ) {
					object t = Workflow.Thread.loadNotesView(errandThread.thread.id);
					if( t ) {
						n = t.notes.objectWithID(note);
						if( n ) {
							t.setValue('notes', t.notes.removeObjectWithID(n.id));
							t.save();
							n.delete();
						}
					}
				}
				break;
			case 'client':
				errandThread = Workflow.Errand.loadClientView(errand);
				if( errandThread and errandThread.client ) {
					n = errandThread.client.notes.objectWithID(note);
					if( n ) {
						errandThread.client.setValue('notes', errandThread.client.notes.removeObjectWithID(n.id));
						errandThread.client.save();
						n.delete();
					}
				}
				break;
		}
		return 'removeNote';
	}

	function _getErrandNotes( number errandId ){
		array list = [];
		object errand = Workflow.Errand.loadThreadView( errandId );
		object thread;
		array notes;
		if( errand.thread ){
			thread = Workflow.Thread.loadNotesView( errand.thread.id ); 
			notes = thread.notes.sort(Array.SORT_DESCENDING ) using ( a, b ) {
				if( a.timestampWritten < b.timestampWritten ) return -1;
				if( a.timestampWritten == b.timestampWritten ) return 0;
				if( a.timestampWritten > b.timestampWritten ) return 1;
			};
			notes.each() using ( note ) {
					list[] = [
					'id' => note.id,
					'username' => note.writer.username,
					'note' => note.note,
					'writtenDate' => formatDateTime( note.timestampWritten ),
					'attachments' => (closure {
						array attachmentList = [];
						note.attachments.each() using( attachment ) {
							attachmentList[] = [
								'fileName' => attachment.fileName,
								'downloadURL' => uriForApplicationActionWithCommand('workflow', "note/${note.id}/attachment/${attachment.id}/" + attachment.fileName.urlEncode())
							];
						};
						return attachmentList;
					}).invoke()
				];
			};
			return list;
		}
		return [];
	}

	function _getClientNotes(number errandId ){
		array list = [];
		object errand = Workflow.Errand.loadClientView( errandId );
		if( errand.client ) {
			array notes = errand.client.notes.sort(Array.SORT_DESCENDING ) using ( a, b ) {
				if( a.timestampWritten < b.timestampWritten ) return -1;
				if( a.timestampWritten == b.timestampWritten ) return 0;
				if( a.timestampWritten > b.timestampWritten ) return 1;
			};
			notes.each() using ( note ) {
				list[] = [
					'id' => note.id,
					'username' => note.writer.username,
					'note' => note.note,
					'writtenDate' => formatDateTime(note.timestampWritten),
					'attachments' => (closure {
						array attachmentList = [];
						note.attachments.each() using( attachment ) {
							attachmentList[] = [
								'fileName' => attachment.fileName,
								'downloadURL' => uriForApplicationActionWithCommand('workflow', "note/${note.id}/attachment/${attachment.id}/" + attachment.fileName.urlEncode())
							];
						};
						return attachmentList;
					}).invoke()
				];
			};
			return list;
		}
		return [];
	}
	
}

Cache.page = new CentionBase();
